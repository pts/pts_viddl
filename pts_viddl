#! /usr/bin/python
# by pts@fazekas.hu at Mon Jul 10 23:16:21 CEST 2017
#
# TODO(pts): Fail on disk full. How to detect it? media_scan.py mp4 errors?
#

import os
import pipes
import re
import subprocess
import sys

NUM_RE = re.compile(r'(\d+)\Z')

NUM_K_RE = re.compile(r'(\d+)k\Z')

VIDRES_RE = re.compile(r'(\d+)x(\d+)\Z')

SIMPLE_RE = re.compile(r'[^a-zA-Z0-9]+')

DOWNLOADED_FILENAME_RE = re.compile(
    r'youtube_([-_a-zA-Z0-9]{11})_(.*)[.][.][.]~~~')


def get_simple_title(title):
  return SIMPLE_RE.sub('_', title).strip('_')


def yield_ainfos(data):
  mp4_audio_list = []
  mp4_video_list = []
  for line in data.split('\n'):
    line = line.replace(' only', '-only').replace(',', ' ').replace('@', ' ')
    line = (line + ' ').replace(' (', ' ').replace(') ', ' ')
    items = line.split()
    if len(items) < 2:
      continue
    match = NUM_RE.match(items[0])
    if not match:
      continue
    format_id = int(match.group(1))
    format = items[1]
    del items[:2]  # format_id and format.
    rates = [int(match.group(1)) for item in items
             for match in (NUM_K_RE.match(item),) if match]
    if len(rates) == 1:
      rate = rates[0]
    else:
      rate = None
    matches = [item for item in items if VIDRES_RE.match(item)]
    assert len(matches) <= 1, matches
    vidres = (matches or (None,))[0]
    is_audio_only = 'audio-only' in items
    is_video_only = 'video-only' in items
    if is_audio_only:
      assert not is_video_only, items
      assert 'video' not in items
      items = [item for item in items if item != 'audio-only' and item != 'audio']
      xtype = 'audio-only'
      assert not vidres, items
    elif is_video_only:
      assert not is_audio_only, items
      assert 'audio' not in items
      items = [item for item in items if item != 'video-only' and item != 'video']
      xtype = 'video-only'
      assert vidres, items
    else:
      xtype = 'both'
      assert vidres, items
      items = [item for item in items if item != 'audio' and item != 'video']
    items = [item for item in items if not NUM_K_RE.match(item) and not VIDRES_RE.match(item)]
    yield (format_id, format, xtype, vidres, rates, sorted(items))


def get_dimens(vidres):
  """Returns (width, height)."""
  match = VIDRES_RE.match(vidres)
  assert match, vidres
  return int(match.group(1)), int(match.group(2))


def get_best_format(data):
  """Returns (ext, format_spec)."""
  # We ignore videos with larger than FullHD resolution. Then
  # we consider these videos: mp4 (video-only and multiplexed) and non-mp4
  # non-webm multiplexed. We choose the best by taking the largest (width *
  # height, int(is_video_only), rate). If we've chosen a video-only mp4,
  # then we add the highest-rate audio-only m4a format.
  #
  # What if video-only and multiplexed mp4 have the same resolution? In this
  # case we choose video-only, because it tends to get higher-quality audio.
  # Unfortunately it's not possible to get the video rate of multiplexed.
  #
  # We never choose webm, because `youtube-dl -F' is lying about the
  # resolution of `-f 43', it has 640x360 hardcoded.
  # https://github.com/rg3/youtube-dl/issues/14125
  ainfos = tuple(yield_ainfos(data))
  def multiply(a, b):
    return a * b
  FORMAT_ID, FORMAT, XTYPE, VIDRES, RATES, ITEMS = xrange(6)
  m4a_list = sorted(
      (a[RATES][0], a[FORMAT_ID]) for a in ainfos
      if a[FORMAT] == 'm4a' and a[XTYPE] == 'audio-only')
  vid_list = sorted(
      (multiply(*get_dimens(a[VIDRES])), int(a[XTYPE] == 'video-only'), (a[RATES] or (1,))[0], a[FORMAT_ID], a[FORMAT])
      for a in ainfos
      if (a[FORMAT] == 'mp4' and a[XTYPE] in ('video-only', 'both'))
      or (a[FORMAT] not in ('mp4', 'webm') and a[XTYPE] == 'both'))
  # This can raise an IndexError, but in practice it won't, because not all
  # videos are larger than FullHD.
  while vid_list[-1][0] > 1080 * 1920:
    vid_list.pop()
  if vid_list[-1][1]:  # A video-only mp4.
    return (vid_list[-1][4], '%s+%s' % (vid_list[-1][3], m4a_list[-1][1]))
  else:  # A multiplexed non-mp4 non-webm.
    return (vid_list[-1][4], str(vid_list[-1][3]))

  # TODO(pts): multiplexed is larger than best separate. why?
  # TODO(pts): do we want to keep the larger?
  #    -f 22         15190719 May 26  2013 Title-YYYYYYYYYYY.mp4
  #    -f ...+...    11094855 May 27  2013 youtube_YYYYYYYYYYY_Title.mp4
  #[youtube] YYYYYYYYYYY: Downloading webpage
  #[youtube] YYYYYYYYYYY: Downloading video info webpage
  #[youtube] YYYYYYYYYYY: Extracting video information
  #[youtube] YYYYYYYYYYY: Downloading MPD manifest
  #[info] Available formats for YYYYYYYYYYY:
  #format code  extension  resolution note
  #139          m4a        audio only DASH audio   48k , m4a_dash container, mp4a.40.5@ 48k (22050Hz), 222.58KiB
  #249          webm       audio only DASH audio   49k , 1fps, opus @ 50k, 220.43KiB
  #250          webm       audio only DASH audio   58k , 1fps, opus @ 70k, 250.61KiB
  #171          webm       audio only DASH audio   90k , 1fps, vorbis@128k, 414.64KiB
  #140          m4a        audio only DASH audio  127k , m4a_dash container, mp4a.40.2@128k (44100Hz), 592.33KiB
  #251          webm       audio only DASH audio  150k , 1fps, opus @160k, 672.49KiB
  #160          mp4        256x144    DASH video  103k , avc1.42c00b, 15fps, video only, 453.03KiB
  #133          mp4        426x240    DASH video  274k , avc1.4d4015, 30fps, video only, 1.23MiB
  #134          mp4        640x360    DASH video  487k , avc1.4d401e, 30fps, video only, 2.18MiB
  #135          mp4        854x480    DASH video 1120k , avc1.4d401f, 30fps, video only, 4.99MiB
  #136          mp4        1280x720   DASH video 2231k , avc1.4d401f, 30fps, video only, 10.00MiB
  #17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #36           3gp        320x180    small , mp4v.20.3, mp4a.40.2
  #43           webm       640x360    medium , vp8.0, vorbis@128k
  #18           mp4        640x360    medium , avc1.42001E, mp4a.40.2@ 96k
  #22           mp4        1280x720   hd720 , avc1.64001F, mp4a.40.2@192k (best)



def download_youtube_video(id_or_url):
  if len(id_or_url) == 11:
    prefix = 'youtube_%s_' % id_or_url
    if [1 for e in os.listdir('.') if e.startswith(prefix)]:
      print >>sys.stderr, 'info: skipping already downloaded: %s' % id_or_url
      return
  p = subprocess.Popen(
      ('youtube-dl', '-F', '--', id_or_url),
      stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  try:
    p.stdin.close()
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    # TODO(pts): ERROR: YYYYYYYYYYY: YouTube said: This video does not exist.
    # RuntimeError: youtube-dl -F failed with exit code 1
    raise RuntimeError('youtube-dl -F failed with exit code %d' % exit_code)
  ext, format_spec = get_best_format(data)
  tmp_prefix = 'youtubetmp.%d.' % os.getpid()
  try:
    # We need the ~~~ delimiter because youtube-dl is trying to be smart and
    # appends .mp4 to the output filename after multiplexing.
    cmd = ('youtube-dl', '-f', format_spec,
           '-o', tmp_prefix + 'youtube_%(id)s_%(title)s...~~~', '--', id_or_url)
    print >>sys.stderr, 'info: downloading with: %s' % (
        ' '.join(map(pipes.quote, cmd)))
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
    try:
      p.stdin.close()
    finally:
      exit_code = p.wait()
    if exit_code:
      raise RuntimeError('youtube-dl failed with exit code %d' % exit_code)
    filenames = [e for e in os.listdir('.') if e.startswith(tmp_prefix)]
    if not filenames:
      raise ValueError('Not files downloaded.')
    if len(filenames) > 1:
      raise ValueError('Multiple files downloaded: %r' % (filenames,))
    match = DOWNLOADED_FILENAME_RE.match(filenames[0][len(tmp_prefix):])
    if not match:
      raise ValueError('Unrecognized downloaded filename: %s' % filenames[0])
    youtube_id, title = match.group(1), match.group(2)
    simple_title = get_simple_title(title)
    saved_filename = 'youtube_%s_%s.%s' % (youtube_id, simple_title, ext)
    print >>sys.stderr, (
        'info: renaming downloaded video to: %s' % saved_filename)
    os.rename(filenames[0], saved_filename)
  finally:
    # Cleanup: delete temporary files.
    for entry in os.listdir('.'):
      if entry.startswith(tmp_prefix):
        try:
          os.remove(entry)
        except OSError:
          pass


def main(argv):
  had_error = False
  for arg in argv[1:]:
    try:
      download_youtube_video(arg)
    except (RuntimeError, ValueError), e:
      print >>sys.stderr, 'error: %s.%s: %s' % (
          e.__class__.__module__, e.__class__.__name__, e)
      had_error = True
  if had_error:
    sys.exit(2)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
