#! /usr/bin/python
# by pts@fazekas.hu at Mon Jul 10 23:16:21 CEST 2017
#
# TODO(pts): Fail on disk full. How to detect it? media_scan.py mp4 errors?
#

import os
import pipes
import re
import subprocess
import sys

NUM_RE = re.compile(r'(\d+)\Z')

NUM_K_RE = re.compile(r'(\d+)k\Z')

VIDRES_RE = re.compile(r'(\d+)x(\d+)\Z')

SIMPLE_RE = re.compile(r'[^a-zA-Z0-9]+')

DOWNLOADED_FILENAME_RE = re.compile(
    r'youtube_([-_a-zA-Z0-9]{11})_(.*)[.][.][.]~~~')


def get_simple_title(title):
  return SIMPLE_RE.sub('_', title).strip('_')


def get_best_format_old_unused(data):
  """Returns (ext, format_spec)."""
  # --- This is old and unused code. ---
  mp4_audio_list = []
  mp4_video_list = []
  for line in data.split('\n'):
    line = line.replace(' only', '-only').replace(',', ' ').replace('@  ', '@').replace('@ ', '@')
    items = line.split()
    if len(items) < 2:
      continue
    match = NUM_RE.match(items[0])
    if not match:
      continue
    format_id = int(match.group(1))
    format = items[1]
    rates = [int(match.group(1)) for item in items
             for match in (NUM_K_RE.match(item),) if match]
    if len(rates) == 1:
      rate = rates[0]
    else:
      rate = None
    if format == 'm4a' and 'audio-only' in items and 'DASH' in items:
      assert rate is not None, items
      mp4_audio_list.append((rate, format_id))
    if format == 'mp4' and 'video-only' in items:
      assert rate is not None
      mp4_video_list.append((rate, format_id))
  # SUXX: The rate of a multiplexed file is not displayed.
  return 'mp4', '%d+%d' % (max(mp4_video_list)[1], max(mp4_audio_list)[1])

  assert mp4_audio_list
  assert mp4_video_list
  # TODO(pts): use webm or flv if it's the best
  # TODO(pts): SUXX: sometimes the webm has some unexpectedly large resolution (640x360, also with old codec vp8.0), should be discarded.
  #    [info] Available formats for YYYYYYYYYYY:
  #    format code  extension  resolution note
  #    139          m4a        audio only DASH audio   48k , m4a_dash container, mp4a.40.5@ 48k (22050Hz), 160.13KiB
  #    249          webm       audio only DASH audio   50k , opus @ 50k, 161.69KiB
  #    250          webm       audio only DASH audio   63k , opus @ 70k, 204.40KiB
  #    171          webm       audio only DASH audio   91k , vorbis@128k, 291.51KiB
  #    140          m4a        audio only DASH audio   97k , m4a_dash container, mp4a.40.2@128k (44100Hz), 318.80KiB
  #    251          webm       audio only DASH audio  115k , opus @160k, 375.76KiB
  #    278          webm       82x144     144p   57k , webm container, vp9, 15fps, video only, 124.22KiB
  #    160          mp4        82x144     DASH video  110k , avc1.4d400c, 15fps, video only, 361.88KiB
  #    242          webm       136x240    144p  163k , vp9, 30fps, video only, 384.46KiB
  #    133          mp4        136x240    DASH video  246k , avc1.4d400d, 30fps, video only, 805.46KiB
  #    134          mp4        204x360    DASH video  253k , avc1.4d400d, 30fps, video only, 764.68KiB
  #    243          webm       204x360    240p  279k , vp9, 30fps, video only, 663.42KiB
  #    244          webm       272x480    240p  405k , vp9, 30fps, video only, 1.03MiB
  #    135          mp4        272x480    DASH video  488k , avc1.4d4015, 30fps, video only, 1.55MiB
  #    17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #    36           3gp        136x240    small , mp4v.20.3, mp4a.40.2
  #    18           mp4        204x360    medium , avc1.42001E, mp4a.40.2@ 96k
  #    43           webm       640x360    medium , vp8.0, vorbis@128k (best)
  # TODO(pts): format=18 (multiplexed mp4) is larger
  #    format=43 (multiplexed webm) is even larger
  #    are these just scaleups?
  #    format code  extension  resolution note
  #    249          webm       audio only DASH audio   52k , opus @ 50k, 1.35MiB
  #    250          webm       audio only DASH audio   69k , opus @ 70k, 1.74MiB
  #    140          m4a        audio only DASH audio   95k , m4a_dash container, mp4a.40.2@128k, 2.59MiB
  #    171          webm       audio only DASH audio   96k , vorbis@128k, 2.52MiB
  #    251          webm       audio only DASH audio  123k , opus @160k, 3.21MiB
  #    160          mp4        256x144    144p  113k , avc1.42c00c, 15fps, video only, 2.96MiB
  #    278          webm       256x144    144p  155k , webm container, vp9, 15fps, video only, 2.47MiB
  #    133          mp4        426x240    240p  246k , avc1.4d4015, 30fps, video only, 6.66MiB
  #    242          webm       426x240    240p  260k , vp9, 30fps, video only, 6.23MiB
  #    17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #    36           3gp        320x180    small , mp4v.20.3, mp4a.40.2
  #    18           mp4        568x320    medium , avc1.42001E, mp4a.40.2@ 96k
  #    43           webm       640x360    medium , vp8.0, vorbis@128k (best)
  # TODO(pts): format=43 is too large
  #    [info] Available formats for YYYYYYYYYYY:
  #    format code  extension  resolution note
  #    139          m4a        audio only DASH audio   48k , m4a_dash container, mp4a.40.5@ 48k (22050Hz), 1.23MiB
  #    249          webm       audio only DASH audio   55k , opus @ 50k, 1.32MiB
  #    250          webm       audio only DASH audio   68k , opus @ 70k, 1.71MiB
  #    140          m4a        audio only DASH audio   95k , m4a_dash container, mp4a.40.2@128k (44100Hz), 2.45MiB
  #    251          webm       audio only DASH audio  124k , opus @160k, 3.14MiB
  #    171          webm       audio only DASH audio  146k , vorbis@128k, 3.52MiB
  #    278          webm       192x144    144p   59k , webm container, vp9, 10fps, video only, 1.06MiB
  #    242          webm       192x144    144p   65k , vp9, 10fps, video only, 620.48KiB
  #    160          mp4        192x144    DASH video  110k , avc1.42c00c, 10fps, video only, 2.80MiB
  #    133          mp4        192x144    DASH video  250k , avc1.4d400d, 10fps, video only, 5.74MiB
  #    17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #    18           mp4        192x144    medium , avc1.42001E, mp4a.40.2@ 96k
  #    43           webm       640x360    medium , vp8.0, vorbis@128k (best)
  # TODO(pts): [info] Available formats for YYYYYYYYYYY:
  #   format code  extension  resolution note
  #   139          m4a        audio only DASH audio   49k , m4a_dash container, mp4a.40.5@ 48k (22050Hz)
  #   140          m4a        audio only DASH audio   96k , m4a_dash container, mp4a.40.2@128k (44100Hz)
  #   160          mp4        256x144    DASH video  108k , avc1.4d400b, 30fps, video only
  #   133          mp4        426x240    DASH video  264k , avc1.4d4015, 30fps, video only
  #   17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #   36           3gp        320x180    small , mp4v.20.3, mp4a.40.2
  #   18           mp4        568x320    medium , avc1.42001E, mp4a.40.2@ 96k
  #   43           webm       640x360    medium , vp8.0, vorbis@128k (best)
  # Actual dimensions:
  #   format=mp4 acodec=mp4a anch=2 arate=44100 asbits=16 has_early_mdat=1 hdr_done_at=3708155 height=240 minor_version=512 size=3708155 subformat=isom vcodec=h264 width=426 f=youtube_YYYYYYYYYYY_Title...+++.merged.mp4
  #   format=mp4 acodec=mp4a anch=1 arate=44100 asbits=16 has_early_mdat=0 hdr_done_at=28651 height=320 minor_version=0 size=7720267 subformat=mp42 vcodec=h264 width=568 f=youtube_YYYYYYYYYYY_Title...+++.mp4
  #   format=webm acodec=vorbis anch=1 arate=44100 asbits=32 hdr_done_at=4335 height=320 size=9293309 subformat=webm vcodec=vp8 width=568 f=youtube_YYYYYYYYYYY_Title...+++.webm
  # Interpretation:
  # * best .webm is not larger larger than best .mp4
  # * `youtube-dl -F' is lying about the dimensions of .webm (-f 43): the lie is 640x360, actual is 568x320
  # * .mp4 dimensions are as advertised (568x320 and 426x240)
  # * largest single-file .mp4 (-f 18 568x320) is larger than the largest megrged .mp4 (426x240)  return 'mp4', '%d+%d' % (max(mp4_video_list)[1], max(mp4_audio_list)[1])


def yield_ainfos(data):
  mp4_audio_list = []
  mp4_video_list = []
  for line in data.split('\n'):
    line = line.replace(' only', '-only').replace(',', ' ').replace('@', ' ')
    line = (line + ' ').replace(' (', ' ').replace(') ', ' ')
    items = line.split()
    if len(items) < 2:
      continue
    match = NUM_RE.match(items[0])
    if not match:
      continue
    format_id = int(match.group(1))
    format = items[1]
    del items[:2]  # format_id and format.
    rates = [int(match.group(1)) for item in items
             for match in (NUM_K_RE.match(item),) if match]
    if len(rates) == 1:
      rate = rates[0]
    else:
      rate = None
    matches = [item for item in items if VIDRES_RE.match(item)]
    assert len(matches) <= 1, matches
    vidres = (matches or (None,))[0]
    is_audio_only = 'audio-only' in items
    is_video_only = 'video-only' in items
    if is_audio_only:
      assert not is_video_only, items
      assert 'video' not in items
      items = [item for item in items if item != 'audio-only' and item != 'audio']
      xtype = 'audio-only'
      assert not vidres, items
    elif is_video_only:
      assert not is_audio_only, items
      assert 'audio' not in items
      items = [item for item in items if item != 'video-only' and item != 'video']
      xtype = 'video-only'
      assert vidres, items
    else:
      xtype = 'both'
      assert vidres, items
      items = [item for item in items if item != 'audio' and item != 'video']
    items = [item for item in items if not NUM_K_RE.match(item) and not VIDRES_RE.match(item)]
    yield (format_id, format, xtype, vidres, rates, sorted(items))


def get_dimens(vidres):
  """Returns (width, height)."""
  match = VIDRES_RE.match(vidres)
  assert match, vidres
  return int(match.group(1)), int(match.group(2))


def get_best_format(data):
  """Returns (ext, format_spec)."""
  # We ignore videos with larger than FullHD resolution. Then
  # we consider these videos: mp4 (video-only and multiplexed) and non-mp4
  # non-webm multiplexed. We choose the best by taking the largest (width *
  # height, int(is_video_only), rate). If we've chosen a video-only mp4,
  # then we add the highest-rate audio-only m4a format.
  #
  # What if video-only and multiplexed mp4 have the same resolution? In this
  # case we choose video-only, because it tends to get higher-quality audio.
  # Unfortunately it's not possible to get the video rate of multiplexed.
  #
  # We never choose webm, because `youtube-dl -F' is lying about the
  # resolution of `-f 43', it has 640x360 hardcoded.
  # https://github.com/rg3/youtube-dl/issues/14125
  ainfos = tuple(yield_ainfos(data))
  def multiply(a, b):
    return a * b
  FORMAT_ID, FORMAT, XTYPE, VIDRES, RATES, ITEMS = xrange(6)
  m4a_list = sorted(
      (a[RATES][0], a[FORMAT_ID]) for a in ainfos
      if a[FORMAT] == 'm4a' and a[XTYPE] == 'audio-only')
  vid_list = sorted(
      (multiply(*get_dimens(a[VIDRES])), int(a[XTYPE] == 'video-only'), (a[RATES] or (1,))[0], a[FORMAT_ID], a[FORMAT])
      for a in ainfos
      if (a[FORMAT] == 'mp4' and a[XTYPE] in ('video-only', 'both'))
      or (a[FORMAT] not in ('mp4', 'webm') and a[XTYPE] == 'both'))
  # This can raise an IndexError, but in practice it won't, because not all
  # videos are larger than FullHD.
  while vid_list[-1][0] > 1080 * 1920:
    vid_list.pop()
  if vid_list[-1][1]:  # A video-only mp4.
    return (vid_list[-1][4], '%s+%s' % (vid_list[-1][3], m4a_list[-1][1]))
  else:  # A multiplexed non-mp4 non-webm.
    return (vid_list[-1][4], str(vid_list[-1][3]))

  # TODO(pts): multiplexed is larger than best separate. why?
  # TODO(pts): do we want to keep the larger?
  #    -f 22         15190719 May 26  2013 Title-YYYYYYYYYYY.mp4
  #    -f ...+...    11094855 May 27  2013 youtube_YYYYYYYYYYY_Title.mp4
  #[youtube] YYYYYYYYYYY: Downloading webpage
  #[youtube] YYYYYYYYYYY: Downloading video info webpage
  #[youtube] YYYYYYYYYYY: Extracting video information
  #[youtube] YYYYYYYYYYY: Downloading MPD manifest
  #[info] Available formats for YYYYYYYYYYY:
  #format code  extension  resolution note
  #139          m4a        audio only DASH audio   48k , m4a_dash container, mp4a.40.5@ 48k (22050Hz), 222.58KiB
  #249          webm       audio only DASH audio   49k , 1fps, opus @ 50k, 220.43KiB
  #250          webm       audio only DASH audio   58k , 1fps, opus @ 70k, 250.61KiB
  #171          webm       audio only DASH audio   90k , 1fps, vorbis@128k, 414.64KiB
  #140          m4a        audio only DASH audio  127k , m4a_dash container, mp4a.40.2@128k (44100Hz), 592.33KiB
  #251          webm       audio only DASH audio  150k , 1fps, opus @160k, 672.49KiB
  #160          mp4        256x144    DASH video  103k , avc1.42c00b, 15fps, video only, 453.03KiB
  #133          mp4        426x240    DASH video  274k , avc1.4d4015, 30fps, video only, 1.23MiB
  #134          mp4        640x360    DASH video  487k , avc1.4d401e, 30fps, video only, 2.18MiB
  #135          mp4        854x480    DASH video 1120k , avc1.4d401f, 30fps, video only, 4.99MiB
  #136          mp4        1280x720   DASH video 2231k , avc1.4d401f, 30fps, video only, 10.00MiB
  #17           3gp        176x144    small , mp4v.20.3, mp4a.40.2@ 24k
  #36           3gp        320x180    small , mp4v.20.3, mp4a.40.2
  #43           webm       640x360    medium , vp8.0, vorbis@128k
  #18           mp4        640x360    medium , avc1.42001E, mp4a.40.2@ 96k
  #22           mp4        1280x720   hd720 , avc1.64001F, mp4a.40.2@192k (best)



def download_youtube_video(id_or_url):
  if len(id_or_url) == 11:
    prefix = 'youtube_%s_' % id_or_url
    if [1 for e in os.listdir('.') if e.startswith(prefix)]:
      print >>sys.stderr, 'info: skipping already downloaded: %s' % id_or_url
      return
  p = subprocess.Popen(
      ('youtube-dl', '-F', '--', id_or_url),
      stdin=subprocess.PIPE, stdout=subprocess.PIPE)
  try:
    p.stdin.close()
    data = p.stdout.read()
  finally:
    exit_code = p.wait()
  if exit_code:
    # TODO(pts): ERROR: YYYYYYYYYYY: YouTube said: This video does not exist.
    # RuntimeError: youtube-dl -F failed with exit code 1
    raise RuntimeError('youtube-dl -F failed with exit code %d' % exit_code)
  ext, format_spec = get_best_format(data)
  tmp_prefix = 'youtubetmp.%d.' % os.getpid()
  try:
    # We need the ~~~ delimiter because youtube-dl is trying to be smart and
    # appends .mp4 to the output filename after multiplexing.
    cmd = ('youtube-dl', '-f', format_spec,
           '-o', tmp_prefix + 'youtube_%(id)s_%(title)s...~~~', '--', id_or_url)
    print >>sys.stderr, 'info: downloading with: %s' % (
        ' '.join(map(pipes.quote, cmd)))
    p = subprocess.Popen(cmd, stdin=subprocess.PIPE)
    try:
      p.stdin.close()
    finally:
      exit_code = p.wait()
    if exit_code:
      raise RuntimeError('youtube-dl failed with exit code %d' % exit_code)
    filenames = [e for e in os.listdir('.') if e.startswith(tmp_prefix)]
    if not filenames:
      raise ValueError('Not files downloaded.')
    if len(filenames) > 1:
      raise ValueError('Multiple files downloaded: %r' % (filenames,))
    match = DOWNLOADED_FILENAME_RE.match(filenames[0][len(tmp_prefix):])
    if not match:
      raise ValueError('Unrecognized downloaded filename: %s' % filenames[0])
    youtube_id, title = match.group(1), match.group(2)
    simple_title = get_simple_title(title)
    saved_filename = 'youtube_%s_%s.%s' % (youtube_id, simple_title, ext)
    print >>sys.stderr, (
        'info: renaming downloaded video to: %s' % saved_filename)
    os.rename(filenames[0], saved_filename)
  finally:
    # Cleanup: delete temporary files.
    for entry in os.listdir('.'):
      if entry.startswith(tmp_prefix):
        try:
          os.remove(entry)
        except OSError:
          pass


def main(argv):
  had_error = False
  for arg in argv[1:]:
    try:
      download_youtube_video(arg)
    except (RuntimeError, ValueError), e:
      print >>sys.stderr, 'error: %s.%s: %s' % (
          e.__class__.__module__, e.__class__.__name__, e)
      had_error = True
  if had_error:
    sys.exit(2)


if __name__ == '__main__':
  sys.exit(main(sys.argv))
